# Score Vulnerability

본 디렉토리는 VScoreFuzz의 취약점 점수를 매기는 LLM 모듈을 구성하고 있습니다.

## 시작하기

```
`
├─ select_pp_branch.py
├─ strip_comments.py
├─ score_vulnerability.py
├─ prompt.txt
├─ instrumenter.py
├─ magma/
├─ in/
└─ targets/

```

### 1. `select_pp_branch.py`

해당 파일은 MAGMA 벤치마크의 패치가 적용된 소스 코드에서 조건에 따른 브랜치 선택을 제거합니다.  
libpng의 png.c 파일을 예로 들면, 

```c
void PNGAPI
png_image_free(png_imagep image)
{
   /* Safely call the real function, but only if doing so is safe at this point
    * (if not inside an error handling context).  Otherwise assume
    * png_safe_execute will call this API after the return.
    */
   if (image != NULL && image->opaque != NULL &&
      image->opaque->error_buf == NULL)
   {
#ifdef MAGMA_ENABLE_FIXES
      png_image_free_function(image);
#else
      (void)png_safe_execute(image, png_image_free_function, image);
#endif
      image->opaque = NULL;
   }
}
```

와 같이, `#ifdef` `#else`는 LLM에게 힌트가 될 수 있으며, 아래처럼 특정 경로를 제외한 모든 경로를 제거합니다.

```c
void PNGAPI
png_image_free(png_imagep image)
{
   /* Safely call the real function, but only if doing so is safe at this point
    * (if not inside an error handling context).  Otherwise assume
    * png_safe_execute will call this API after the return.
    */
   if (image != NULL && image->opaque != NULL &&
      image->opaque->error_buf == NULL)
   {
      png_image_free_function(image);
      image->opaque = NULL;
   }
}
```

`select_pp_branch.py` 의 사용법은 다음과 같습니다.

```bash

# python select_pp_branch.py {input} {output} --macro {MACRO} {--keep-defined / --keep-undefined}
python select_pp_branch.py \
    in/png.c \
    in/png.c.vul \
    --macro MAGMA_ENABLE_FIXES \
    --keep-defined

```

### 2. `strip_comments.py`

해당 파일은 LLM의 입력 최소화와 기타 LLM에게 힌트가 될 수 있는 주석을 제거하기 위한 파일입니다.  
`strip_comments.py` 의 사용 방법은 다음과 같습니다.  

```bash

# python strip_comments.py {input} {output} --mode [remove-all, remove-keyword] --keywords {keywords}
python strip_comments.py \
    in/png.c.vul \
    in/png.c.vul.clean \
    --mode remove-all

```

remove-all은 모든 주석 제거, remove-keyword는 특정 단어가 포함된 주석만 제거하는 모드입니다.  
원래는 MAGMA 라는 키워드가 포함된 모든 주석을 제거하기 위해 만들어진 코드였지만,  
주석이 LLM의 문맥 형성에 필수적이지 않고, 입력 길이를 최소화하기 위해 remove-all을 default로 두었습니다.  

### 3. `score_vulnerability.py`

해당 파일은 Function-level, 그리고 Cross-function-level의 취약점을 탐지하기 위한 코드입니다.  
LLM을 호출하여 취약점 점수를 매길 수 있습니다.  
`score_vulnerability.py` 의 사용 방법은 다음과 같습니다.  

```bash

python score_vulnerability.py

```

별도의 옵션은 제공하고 있지 않으며, 아직 실험적인 단계이기에, 모든 경로가 하드코딩되어 있습니다.  
코드 내부의 `model_id`를 수정하여 LLM을 교체할 수 있습니다 (huggingface 기준 ID).  
`system_prompt`의 `./prompt.txt`, `user_prompt`의 `./in/png.c.vul.clean`을 수정하여 특정 목표 파일로 교체할 수 있습니다.  
`./out/png.c.vul.clean`을 수정하여 출력 파일명을 교체할 수 있습니다.  

출력된 파일은 다음의 형태를 띱니다.

```
Okay, I'm trying to analyze this C source file for security vulnerabilities. Let me go through it step by step.
First, I'll list all the top-level functions. There are quite a few, so I'll need to go through each one carefully.
Looking at `png_set_sig_bytes`, it seems to handle signature bytes. It checks if `num_bytes` is negative and sets it to 0, but I don't see any issues here. The score is 0.
Next, `png_sig_cmp` compares signatures. It has some bounds checking, but if `start` is 7 and `num_to_check` is 8, it might read beyond the array. That's a buffer overflow risk. Score 3.
`png_zalloc` handles memory allocation. It checks for overflow in `items * size` but uses a cast that might not handle all cases. Still, it's cautious. Score 1.
`png_zfree` frees memory. It looks straightforward, no issues. Score 0.
`png_reset_crc` initializes CRC. No issues. Score 0.
...
`png_set_option` sets options. It checks for valid options. Score 0.

The functions `png_image_free` and `png_image_error` handle image cleanup. They might have issues with resource management. Score 1 each.
Now, looking for cross-function vulnerabilities. The main issue is in `png_sig_cmp` where `start + num_to_check` might exceed the array size, leading to a buffer overflow. This is a high severity issue.
Another potential issue is in `png_zalloc` where the overflow check might not cover all cases, leading to integer overflow. This is medium severity.
In `png_create_png_struct`, if `png_malloc_warn` fails, it might leak memory, leading to a Use-After-Free. This is medium severity.
Overall, the most critical issue is the buffer overflow in `png_sig_cmp`.
</think>

```json
{
  "function_scores": {
    "png_set_sig_bytes": {"score": 0, "rationale": "No issues found, handles negative values correctly."},
    "png_sig_cmp": {"score": 3, "rationale": "Potential buffer overflow if start + num_to_check exceeds array bounds."},
    "png_zalloc": {"score": 1, "rationale": "Checks for overflow but uses a cast that might not handle all cases."},
    ...
    "png_image_error": {"score": 1, "rationale": "Potential resource management issues."}
  },
  "vulnerabilities": [
    {
      "title": "Buffer Overflow",
      "vulnerability_path": "png_sig_cmp",
      "concrete_evidence": "if (start + num_to_check > 8) num_to_check = 8 - start;",
      "trigger_preconditions": "start + num_to_check exceeds 8",
      "exploitability_assessment": "High",
      "overall_severity_score": 5,
      "evidence_level": "Certain"
    },
    {
      "title": "Integer Overflow",
      "vulnerability_path": "png_zalloc",
      "concrete_evidence": "if (items >= (~(png_alloc_size_t)0)/size) { png_warning(...); return NULL; }",
      "trigger_preconditions": "items * size exceeds system limits",
      "exploitability_assessment": "Medium",
      "overall_severity_score": 4,
      "evidence_level": "Certain"
    },
    {
      "title": "Use-After-Free",
      "vulnerability_path": "png_create_png_struct -> png_malloc_warn",
      "concrete_evidence": "if (png_ptr->sig_bytes = (png_byte)nb;)",
      "trigger_preconditions": "png_malloc_warn returns NULL",
      "exploitability_assessment": "Medium",
      "overall_severity_score": 4,
      "evidence_level": "Certain"
    }
  ]
}
\`\`\`

**Summary:**
The most critical vulnerability is a buffer overflow in `png_sig_cmp` when `start + num_to_check` exceeds the array bounds. This is a high-severity issue. Additionally, there are integer overflow and potential Use-After-Free issues in other functions.

```

### 4. `instrumenter.py`

해당 파일은 LLM의 출력을 기반으로 PUT에 계측 코드를 넣기 위한 코드입니다.  
`instrumenter.py` 의 사용 방법은 다음과 같습니다.  

```bash
python instrumenter.py
```

해당 파일도 `score_vulnerability.py`와 마찬가지로 별도의 옵션은 제공하고 있지 않으며, 아직 실험적인 단계이기에, 모든 경로가 하드코딩되어 있습니다.  
코드의 최상단에 `JSON_FILE`, `SOURCE_FILE`, `OUTPUT_FILE`, `REPORT_FILENAME`을 수정하여 원하는 파일로 교체할 수 있습니다.

- `JSON_FILE`: 출력된 LLM 응답, 소스 코드에서 ```json ``` 코드 블록을 인식하여 추출함. (default: out/png.c.vul.clean)
- `SOURCE_FILE`: 계측 코드를 삽입할 PUT 코드. (default: in/png.c.vul.clean)
- `OUTPUT_FILE`: 계측 코드가 삽입된 출력 파일 경로. (default: out/png.c.vul.clean.instrumented)
- `REPORT_FILENAME`: 계측된 정보가 출력될 파일 이름. 이는 계측 코드가 삽입된 코드에서, save_vuln_score() 함수를 호출하면 해당 이름으로 스코어가 작성된 파일이 생성됨. (default: report.txt)

### 5. 실행

위 파일로 계측 코드까지 삽입했다면, `magma/aflplusplus-libpng.sh` 를 통해 바로 실행시킬 수 있습니다.  
참고로 `magma/targets/libpng/fetch.sh` 파일을 수정하여, `repo/contrib/contrib/oss-fuzz/libpng_read_fuzzer.cc` 파일에 직접 취약점 점수 (global unsigned long)와 파일 출력 함수를 작성하도록 구현되어 있으며,  
결과로 출력되는 report.txt 파일은 `magma/tools/captain/workdir/report.txt` 경로에서 찾을 수 있습니다.  
