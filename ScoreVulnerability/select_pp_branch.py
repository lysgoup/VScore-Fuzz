#!/usr/bin/env python3
"""
select_pp_branch.py

Usage:
  python select_pp_branch.py input.c output.c --macro MAGMA_ENABLE_FIXES --keep-defined

Behavior:
  Keep only the branch corresponding to the macro condition.
  - For `#ifdef MACRO`:
      --keep-defined  -> keep the code under the #ifdef (before #else/#endif)
      --keep-undefined -> keep the #else branch (if present)
  - For `#ifndef MACRO`: inverted semantics.
  - For `#if` and `#elif`: the script attempts to detect `defined(MACRO)` or `!defined(MACRO)` patterns.
  - Nested conditionals are handled.
  - All preprocessor directive lines are removed in output.
"""
import re
import sys
import argparse

directive_re = re.compile(r'^\s*#\s*(if|ifdef|ifndef|elif|else|endif)\b(.*)$')

def expr_mentions_macro(expr, macro):
    # naive checks for defined(MACRO), !defined(MACRO), or direct MACRO token
    if expr is None:
        return False
    if re.search(r'\bdefined\s*\(\s*' + re.escape(macro) + r'\s*\)', expr):
        return True
    if re.search(r'\b!' + r'\s*defined\s*\(\s*' + re.escape(macro) + r'\s*\)', expr):
        return True
    # also check simple token presence (risky for complex expressions)
    if re.search(r'\b' + re.escape(macro) + r'\b', expr):
        return True
    return False

def should_keep_for_if(kind, expr, macro, keep_defined):
    """
    Return two values:
      (first_branch_kept, else_branch_kept)
    where kind is 'ifdef'|'ifndef'|'if'
    keep_defined True => user wants branch where macro is defined
    """
    if kind == 'ifdef':
        return (keep_defined, not keep_defined)
    if kind == 'ifndef':
        # inverted
        return (not keep_defined, keep_defined)
    # kind == 'if' or 'elif', attempt to reason
    if expr is None:
        return (True, True)  # unknown -> keep both conservatively
    expr = expr.strip()
    # if expression explicitly mentions defined(macro)
    if re.search(r'\bdefined\s*\(\s*' + re.escape(macro) + r'\s*\)', expr):
        # if expr is positive defined(macro)
        return (keep_defined, not keep_defined)
    # check for negated form
    if re.search(r'\b!\s*defined\s*\(\s*' + re.escape(macro) + r'\s*\)', expr):
        return (not keep_defined, keep_defined)
    # fallback: if macro token appears -> treat as unknown
    if re.search(r'\b' + re.escape(macro) + r'\b', expr):
        return (True, True)
    return (True, True)

def process(input_text, macro, keep_defined=True):
    out_lines = []
    stack = []  # each entry: dict {first_branch_kept, else_branch_kept, in_else, active_emit}
    lines = input_text.splitlines(True)
    for i, line in enumerate(lines, start=1):
        m = directive_re.match(line)
        if not m:
            # Non-directive line: decide whether to emit based on stack
            emit = True
            for level in stack:
                if not level['active_emit']:
                    emit = False
                    break
            if emit:
                out_lines.append(line)
            continue

        kind = m.group(1)  # if/ifdef/...
        expr = m.group(2).strip() if m.group(2) else ""

        if kind in ('ifdef', 'ifndef', 'if'):
            first_kept, else_kept = should_keep_for_if(kind, expr, macro, keep_defined)
            # determine whether currently in portion to emit (start in first branch)
            active_emit = first_kept and (all(level['active_emit'] for level in stack) if stack else True)
            stack.append({'first_branch_kept': first_kept,
                          'else_branch_kept': else_kept,
                          'in_else': False,
                          'active_emit': active_emit})
            # do NOT emit the directive line itself
            continue

        if kind == 'elif':
            if not stack:
                # unmatched elif -> keep the line (conservative)
                out_lines.append(line)
                continue
            top = stack[-1]
            # move into elif: treat as entering else-like branch; recompute active_emit
            # For simplicity: evaluate this elif expr similarly to #if
            first_kept, else_kept = should_keep_for_if('if', expr, macro, keep_defined)
            # Now, since we're in an elif, the "first" portion is previous first+prior elifs; treat current active as first_kept
            top['in_else'] = False  # still in primary area but representing new condition
            # compute active based on top and outer stack
            outer_ok = all(level['active_emit'] for level in stack[:-1]) if len(stack) > 1 else True
            top['active_emit'] = first_kept and outer_ok
            top['first_branch_kept'] = first_kept
            top['else_branch_kept'] = else_kept
            continue

        if kind == 'else':
            if not stack:
                out_lines.append(line)
                continue
            top = stack[-1]
            top['in_else'] = True
            # recompute active_emit
            outer_ok = all(level['active_emit'] for level in stack[:-1]) if len(stack) > 1 else True
            top['active_emit'] = top['else_branch_kept'] and outer_ok
            continue

        if kind == 'endif':
            if not stack:
                out_lines.append(line)
                continue
            stack.pop()
            continue

    return ''.join(out_lines)

def main():
    parser = argparse.ArgumentParser(description='Keep only the selected preprocessor branch for a macro.')
    parser.add_argument('input', help='input C file')
    parser.add_argument('output', help='output C file')
    parser.add_argument('--macro', required=True, help='macro name to target (e.g., MAGMA_ENABLE_FIXES)')
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('--keep-defined', action='store_true', help='keep branch for when the macro is defined')
    group.add_argument('--keep-undefined', action='store_true', help='keep branch for when the macro is NOT defined')
    args = parser.parse_args()

    with open(args.input, 'r', encoding='utf-8') as f:
        inp = f.read()
    out = process(inp, args.macro, keep_defined=args.keep_defined)
    with open(args.output, 'w', encoding='utf-8') as f:
        f.write(out)
    print(f"Wrote {args.output}")

if __name__ == '__main__':
    main()
