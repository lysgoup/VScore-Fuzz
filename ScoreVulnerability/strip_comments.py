#!/usr/bin/env python3
"""
strip_comments.py

Usage:
  python strip_comments.py input.c output.c [--mode remove-all|remove-keyword] [--keywords "Safety,MAGMA"]

Defaults:
  mode = remove-all

Notes:
  - Creates a backup: input.c.bak
  - Preserves string/char literals (does not remove comment-like tokens inside them).
  - By default preserves line counts (replaces removed comment characters with spaces/newlines).
"""

import sys, argparse, os

def strip_comments_clean(src, remove_keyword_only=False, keywords=None):
    if keywords is None: keywords = []
    i = 0
    n = len(src)
    out_chars = []
    state = 'normal'
    
    while i < n:
        c = src[i]
        nxt = src[i+1] if i+1 < n else ''
        
        if state == 'normal':
            # 문자열/문자 리터럴 처리 (기존과 동일)
            if c == '"' : out_chars.append(c); state = 'in_string'; i += 1; continue
            if c == "'" : out_chars.append(c); state = 'in_char'; i += 1; continue
            
            # 블록 주석 (/* ... */) 시작
            if c == '/' and nxt == '*':
                j = i + 2
                found = False
                while j < n - 1:
                    if src[j] == '*' and src[j+1] == '/':
                        found = True
                        j_end = j + 2
                        break
                    j += 1
                if not found: j_end = n
                
                comment_text = src[i:j_end]
                # (키워드 체크 로직은 동일하게 유지 가능)
                
                # [수정된 부분] 주석을 단순히 공백 한 칸으로 대체
                out_chars.append(' ') 
                i = j_end
                continue
            
            # 라인 주석 (// ...) 시작
            if c == '/' and nxt == '/':
                j = i + 2
                while j < n and src[j] != '\n':
                    j += 1
                # [수정된 부분] 라인 주석은 아예 무시하고 개행만 남기거나 공백 처리
                # 개행은 유지해야 코드 합쳐짐 방지 (int a; //com \n int b;)
                i = j 
                continue
                
            out_chars.append(c)
            i += 1
            continue

        # 문자열/문자 내부 처리 (기존과 동일)
        elif state == 'in_string':
            out_chars.append(c)
            if c == '\\': 
                if i+1 < n: out_chars.append(src[i+1]); i+=2
                else: i+=1
            elif c == '"': state = 'normal'; i+=1
            else: i+=1
            continue
            
        elif state == 'in_char':
            out_chars.append(c)
            if c == '\\':
                if i+1 < n: out_chars.append(src[i+1]); i+=2
                else: i+=1
            elif c == "'": state = 'normal'; i+=1
            else: i+=1
            continue

    # 1차 결과물 (주석은 제거되었으나 빈 줄이 많을 수 있음)
    text = ''.join(out_chars)
    
    # [추가] 연속된 빈 줄(Empty Lines) 제거 로직
    # 빈 줄이 여러 개면 하나로 줄임
    import re
    # 3개 이상의 연속 개행을 2개로 줄이거나, 불필요한 공백 라인 제거
    cleaned_text = re.sub(r'\n\s*\n', '\n', text) 
    
    return cleaned_text

def main():
    ap = argparse.ArgumentParser(description="Strip C/C++ comments while preserving strings and line counts.")
    ap.add_argument('input', help='input C file')
    ap.add_argument('output', help='output C file')
    ap.add_argument('--mode', choices=['remove-all','remove-keyword'], default='remove-all')
    ap.add_argument('--keywords', default='', help='comma-separated keywords to match in comments for remove-keyword mode')
    args = ap.parse_args()

    if not os.path.exists(args.input):
        print("Input not found:", args.input); sys.exit(2)

    with open(args.input, 'r', encoding='utf-8', errors='ignore') as f:
        src = f.read()

    keywords = [k.strip() for k in args.keywords.split(',') if k.strip()]
    remove_keyword_only = (args.mode == 'remove-keyword')

    out_src = strip_comments_clean(src, remove_keyword_only, keywords)
    with open(args.output, 'w', encoding='utf-8') as f:
        f.write(out_src)
    print("Wrote output to", args.output)

if __name__ == '__main__':
    main()
