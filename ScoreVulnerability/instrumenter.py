import json
import re
import os
import sys

# 파일 설정
JSON_FILE = 'out/png.c.vul.clean'
SOURCE_FILE = 'in/png.c.vul.clean'
OUTPUT_FILE = 'out/png.c.vul.clean.instrumented'
REPORT_FILENAME = "report.txt"

def parse_llm_json(content):
    """LLM 응답에서 JSON 추출 (이전과 동일)"""
    think_end_marker = "</think>"
    think_end_index = content.find(think_end_marker)
    if think_end_index != -1:
        content = content[think_end_index + len(think_end_marker):]
    
    pattern = r"```json\s*(\{.*?\})\s*```"
    match = re.search(pattern, content, re.DOTALL)
    
    json_str = ""
    if match:
        json_str = match.group(1)
    else:
        start = content.find('{')
        end = content.rfind('}')
        if start != -1 and end != -1:
            json_str = content[start:end+1]
        else:
            # Fallback: 원본이 순수 JSON일 수도 있음
            json_str = content

    try:
        return json.loads(json_str)
    except json.JSONDecodeError:
        return {}

def load_data(json_path):
    with open(json_path, 'r', encoding='utf-8') as f:
        raw_content = f.read()
    data = parse_llm_json(raw_content)
    
    function_scores = data.get('function_scores', {})
    vulnerabilities = data.get('vulnerabilities', [])
    
    return function_scores, vulnerabilities

def inject_global_tracking_code(source_code):
    """
    전역 변수, 리포팅 함수, 그리고 Context 복구용 헬퍼 함수를 추가합니다.
    """
    tracking_code = f"""
/* [Instrumentation] Global Tracker Declarations */
#include <stdio.h>
#include <stdlib.h>

/* * LINKING FIX:
 * We declare these as extern. The actual definition will be in the Fuzzer code.
 * This bypasses libpng's strict symbol hiding mechanism.
 */
extern unsigned long long g_vuln_score;
extern int g_current_func_id;

/* Helper to restore function ID (Keep this local/static) */
static void restore_func_id(int *prev_id) {{
    g_current_func_id = *prev_id;
}}

/* save_vuln_score implementation is moved to the Fuzzer side */
/* [Instrumentation] End */
"""
    if '#include "pngpriv.h"' in source_code:
        return source_code.replace('#include "pngpriv.h"', '#include "pngpriv.h"\n' + tracking_code)
    else:
        return tracking_code + source_code

def instrument_functions(source_code, func_scores, vulnerabilities):
    instrumented_code = source_code

    # 1. 모든 함수에 고유 ID 부여
    func_name_to_id = {}
    current_id = 1
    for func_name in func_scores.keys():
        func_name_to_id[func_name] = current_id
        current_id += 1

    # 2. 취약점 경로(Path) 데이터를 'Target(Callee)' 중심으로 재정리
    # key: target_func_name, value: list of (caller_func_name, score)
    path_triggers = {}
    
    for vuln in vulnerabilities:
        path_str = vuln.get('vulnerability_path', '')
        score = vuln.get('overall_severity_score', 0)
        
        # "FuncA -> FuncB" 형태 파싱
        if '->' in path_str:
            parts = [p.strip() for p in path_str.split('->')]
            if len(parts) >= 2:
                caller = parts[0]
                target = parts[1] # 단순화를 위해 직전 호출자만 체크 (Chain인 경우 A->B, B->C로 처리 권장)
                
                if target not in path_triggers:
                    path_triggers[target] = []
                path_triggers[target].append((caller, score))

    # 3. 함수별 계측 코드 삽입
    for func_name, info in func_scores.items():
        base_score = info['score']
        my_id = func_name_to_id[func_name]
        
        # Regex로 함수 정의 찾기
        pattern_str = (
            r"(?P<declaration>"
            r"(?:PNG_FUNCTION\s*\([^\)]+?,\s*|"
            r"(?:^|\s)[\w\s\*]+PNGAPI\s+|"
            r"(?:^|\s)(?:static\s+)?(?:const\s+)?[\w\*]+\s+)"
            r"\b" + re.escape(func_name) + r"\b"
            r"[^;\{]*?"
            r"\{)"
        )
        pattern = re.compile(pattern_str, re.DOTALL | re.MULTILINE)

        # 주입할 코드 생성
        injection = f"\n    /* [Instrumentation] {func_name} (ID: {my_id}) */"
        
        # (A) Path Check: 나를 호출한 사람이 '위험한 호출자'인가?
        if func_name in path_triggers:
            for caller_name, path_score in path_triggers[func_name]:
                if caller_name in func_name_to_id:
                    caller_id = func_name_to_id[caller_name]
                    injection += f"\n    if (g_current_func_id == {caller_id}) {{ " \
                                 f"g_vuln_score += {path_score}; " \
                                 f"/* Path Trigger: {caller_name}->{func_name} */ }}"

        # (B) Base Score: 함수 자체 점수
        if base_score > 0:
            injection += f"\n    g_vuln_score += {base_score};"

        # (C) Context Tracking: 내 ID 설정 및 자동 복구 (GCC cleanup 사용)
        injection += f"\n    int _prev_id = g_current_func_id;" \
                     f"\n    int __attribute__((cleanup(restore_func_id))) _cleaner = _prev_id;" \
                     f"\n    g_current_func_id = {my_id};"

        # 치환 수행
        def replacer(match):
            # 중복 방지
            if "g_current_func_id =" in match.string[match.end():match.end()+100]:
                return match.group('declaration')
            return match.group('declaration') + injection

        instrumented_code = pattern.sub(replacer, instrumented_code)

    return instrumented_code

def main():
    print(f"[*] Loading analysis data from {JSON_FILE}...")
    try:
        f_scores, vulns = load_data(JSON_FILE)
        print(f"[*] Found {len(f_scores)} functions and {len(vulns)} vulnerability paths.")
    except Exception as e:
        print(f"[!] Error: {e}")
        return
    
    print(f"[*] Reading source code...")
    if not os.path.exists(SOURCE_FILE):
        print("[!] Source file missing.")
        return
        
    with open(SOURCE_FILE, 'r', encoding='utf-8') as f:
        src = f.read()

    print("[*] Injecting tracking & path detection logic...")
    src = inject_global_tracking_code(src)
    src = instrument_functions(src, f_scores, vulns)

    os.makedirs(os.path.dirname(OUTPUT_FILE), exist_ok=True)
    with open(OUTPUT_FILE, 'w', encoding='utf-8') as f:
        f.write(src)
    
    print(f"[*] Success! Instrumented code saved to: {OUTPUT_FILE}")

if __name__ == "__main__":
    main()
